/*******************************************************
 *************** SAT SOLVER DELUXE V2.0 ****************
 *******************************************************/

/* Team: Computahs */

#include "dpll_structs.h"
#include "input_verifier.c"
#include <assert.h>
#include <stdlib.h>
#include <stdio.h>


/**
 * Concatenates the two arrays, with arr_a's contents preceding arr_b's
 *
 * Returns the pointer to the concatenated array.
 **/
int * concatenate_arrs(int* arr_a, int len_a, int* arr_b, int len_b)
{
  //printf("%d - %d  + %d - %d\n", arr_a, len_a, arr_b, len_b);
   if(arr_a == NULL && len_a == 0)
    return realloc(arr_b, sizeof(int) * len_b);

  if(arr_b == NULL && len_b == 0)
    return realloc(arr_a, sizeof(int) * len_a);

  int* new_arr = realloc(arr_a, sizeof(int) * len_a + sizeof(int) * len_b);
  memcpy(new_arr + len_a, arr_b, sizeof(int) * len_b);
  free(arr_b);
  return new_arr;
}

void print_clause(clause c)
{
  int j = 0;
  for(; j < c.len; j++)
    {
      if(!c.lits[j].is_pos) {
	printf("-");
      } 
      printf("%d(%d|%d)", c.lits[j].eval, c.lits[j].id, c.lits[j].index);
      if(!c.lits[j].is_assigned)
	printf("u");
      printf(" ");
    }
  printf("unassigned: %d, satisfied: %d", c.num_unassigned, c.is_satisfied);
  printf("\n");
}

void print_lit_watch(formula f, int lit_index)
{
  int i = 0;
  printf("%d Overall - assigned=%d, num_clauses=%d\n", 
	 lit_index, f.all_lits[lit_index].lit.is_assigned, f.all_lits[lit_index].num_clauses);
  for(; i < f.all_lits[lit_index].num_clauses; i++)
    {
      clause_index ci = f.all_lits[lit_index].clauses[i];\
      literal cur_lit = f.clauses[ci.clause].lits[ci.index];
      printf("%d -> %d. assigned: %d val: %d\n  ", 
	     ci.clause, ci.index, cur_lit.is_assigned, cur_lit.val);
      print_clause(f.clauses[ci.clause]);
    }
}


void print_formula(formula f)
{
  int i = 0; 
  printf("num_unsatisfied: %d\n", f.num_unsatisfied);
  for(; i < f.num_clauses; i++)
    {
      print_clause(f.clauses[i]);
    }
}

/**
 * Returns the index of the unit literal in the clause
 **/
int find_unit_lit(clause c)
{
  int i = 0;
  for(; i < c.len; i++)
    {
      if(!c.lits[i].is_assigned)
	return i;
    }
  return -1;
}

/**
 * Returns 1 if the formula is satisfied
 **/
int is_satisfied(formula* f)
{
  return f->num_unsatisfied == 0;
}

/**
 * Returns 1 if the formula contains an "empty" clause
 **/
int has_empty_clause(formula* f)
{
  return f->has_empty_clause;
}

/**
 * Returns 0 if the literal in question is not pure
 * Returns positive value if the literal is pure AND should be set to 1
 * Returns negative value if the literal is pure AND should be set to -1
 *
 * Pure literals are defined as only appearing with a single
 * value (+ or -) in the remaining unsatisfied clauses
 **/
int is_pure_literal(lit_clauses lc)
{
  if(!lc.num_unsatisfied)
    return 0;

  if(lc.purity == lc.num_unsatisfied || lc.purity == 0)
    return (lc.purity ? 1 : -1);

  return 0;
}

/**
 * Returns 1 if the clause is a unit clause
 **/
int is_unit_clause(clause c)
{
  return c.num_unassigned == 1;
}

/**
 * Carries out the guess action for the literal at f->all_lits[lit_index]
 * with the given value for the guess.
 *
 * Assigns all instances in the watch list for the literal
 **/
void guess(formula* f, int lit_index, int guess)
{
  // Immediately return if this value has already been guessed
  if(f->all_lits[lit_index].lit.is_assigned)
      return;

  int i;
  int max_unit_clauses = f->all_lits[lit_index].num_clauses;
  int unit_count = 0;
  int* unit_clauses = malloc(sizeof(int) * max_unit_clauses);
  int pure_count = 0;
  int* pure_lits = NULL;
  lit_clauses lc = f->all_lits[lit_index];

  // Loop through the literals in this literal's watch lit, assigning each one
  for(i = 0; i < lc.num_clauses; i++)
    {
      clause_index cl = lc.clauses[i];      
      
      // This literal should NOT yet be currently assigned yet
      //assert(!f->clauses[cl.clause].lits[cl.index].is_assigned);
      
      // Decrement the number of "unassigned" literals in the clause
      f->clauses[cl.clause].num_unassigned--;

      // Assign the guess to the specific literal 
      f->clauses[cl.clause].lits[cl.index].is_assigned = 1;
      f->clauses[cl.clause].lits[cl.index].eval = !(guess ^ f->clauses[cl.clause].lits[cl.index].is_pos);

      // In the case that this literal satisfies the clause
      if(f->clauses[cl.clause].lits[cl.index].eval)
	{
	  
	  // If this clause hasn't been satisfied UNTIL NOW
	  if(!f->clauses[cl.clause].is_satisfied)
	    {
	      // Decrement the number of "unsatisfied" clauses in the formula
	      f->num_unsatisfied--;
	      int lit_ind = 0;
	      int cur_pure_count = 0;
	      int cur_pure_max = f->clauses[cl.clause].len;
	      int* cur_pures = NULL;
	      cur_pures = malloc(sizeof(int) * cur_pure_max);
	      for(; lit_ind < f->clauses[cl.clause].len; lit_ind++)
		{
		  int all_lits_ind = f->clauses[cl.clause].lits[lit_ind].index;
		  f->all_lits[all_lits_ind].num_unsatisfied--;
		  f->all_lits[all_lits_ind].purity -= f->clauses[cl.clause].lits[lit_ind].is_pos;
		  if(lc.lit.id != f->clauses[cl.clause].lits[lit_ind].id && !f->clauses[cl.clause].lits[lit_ind].is_assigned && is_pure_literal(f->all_lits[all_lits_ind]))
		    {
		      cur_pures[cur_pure_count] = all_lits_ind;
		      cur_pure_count++;
		    }
		}

	      pure_lits = concatenate_arrs(pure_lits, pure_count, cur_pures, cur_pure_count);
	      pure_count += cur_pure_count;

	    }
	  // Increment the is_satisfied counter/"boolean"
	  f->clauses[cl.clause].is_satisfied++;
	  
	  // is_satisfied SHOULD be positive after the previous operation
	  assert(f->clauses[cl.clause].is_satisfied > 0);
	}
      else if(!f->clauses[cl.clause].is_satisfied) // Guess DID NOT satisfy it.
	{
	  // If one literal remains, it is a UNIT CLAUSE
	  if(is_unit_clause(f->clauses[cl.clause]))
	    {
	      unit_clauses[unit_count] = cl.clause;
	      unit_count++;
	    }
	  if(f->clauses[cl.clause].num_unassigned == 0)
	    {
	      //printf("Guessing %d to be %d makes clause %d empty\n", f->clauses[cl.clause].lits[cl.index].id, guess, cl.clause);
	      //print_clause(f->clauses[cl.clause]);
	      f->has_empty_clause = 1;
	    }
	}
    }

  // Assign the value of the literal in the all_lits array
  f->all_lits[lit_index].lit.is_assigned = 1;

  f->potential_pures = concatenate_arrs(f->potential_pures, f->potential_pure_count, pure_lits, pure_count);
  f->potential_pure_count += pure_count;
  /*
  int z = 0;
  for(; z < f->potential_pure_count; z++)
    {
      printf("pure #%d: %d (%d)\n", z, f->potential_pures[z], f->all_lits[f->potential_pures[z]].lit.id);
    }
  */
  f->potential_units = concatenate_arrs(f->potential_units, f->potential_unit_count, unit_clauses, unit_count);
  f->potential_unit_count += unit_count;
}

/**
 * Reverts a previous "guess" to the literal all_lits[lit_index]
 **/
void undo_guess(formula* f, int lit_index)
{
  // If this literal is not assigned currently, return immediately.
  if(!f->all_lits[lit_index].lit.is_assigned)
    return;

  int i = 0;
  lit_clauses lc = f->all_lits[lit_index];
  // Loop through the literals in this literal's watch lit, unassigning each one
  for(; i < lc.num_clauses; i++)
    {
      clause_index cl = lc.clauses[i];
      
      // If this literal satisfied the current clause, account for that
      if(f->clauses[cl.clause].lits[cl.index].eval)
	{
	  // Decrement the clause's counter/"boolean" is_satisfied
	  f->clauses[cl.clause].is_satisfied--;

	  // If the clause is no longer satisfied
	  if(!f->clauses[cl.clause].is_satisfied)
	    {
	      // Increment the number of unsatisfied clauses in the formula
	      f->num_unsatisfied++;
	      int lit_ind = 0;
	      for(; lit_ind < f->clauses[cl.clause].len; lit_ind++)
		{		  
		  int all_lits_ind = f->clauses[cl.clause].lits[lit_ind].index; 
		  f->all_lits[all_lits_ind].num_unsatisfied++;
		  f->all_lits[all_lits_ind].purity += f->clauses[cl.clause].lits[lit_ind].is_pos;
		}
	    }
	}

      // Increment the number of unassigned literals in the current clause
      f->clauses[cl.clause].num_unassigned++;
      // Unset the value of the literal 
      f->clauses[cl.clause].lits[cl.index].is_assigned = 0;
    }

  // Unset the literal in the all_lits array
  f->all_lits[lit_index].lit.is_assigned = 0;
}

/**
 * Recursive formula that determines satisfiability of a given formula
 **/
int is_satisfiable(formula * f, int last_guess_clause_ind)
{
  // Return 1 if the formula has been satisfied
  if(is_satisfied(f))
    return 1;
  
  // Return 0 if an empty clause is found
  if(has_empty_clause(f))
    return 0;
  
  int at_least_one_reduced = 1;
  int* unit_lits = NULL;
  int* pure_lits = NULL;
  int unit_count = 0;
  int pure_count = 0;
  // Repeatedly find unit clauses and pure literals, and assign them
  while(at_least_one_reduced)
    {
      int i;
      int cur_unit_count = 0;
      /** Propogate the unit clauses **/

      int* cur_unit_lits = NULL;
      clause_index* cur_unit_clauses = NULL;

      // If potential_units has not been set, check ALL clauses
      if(last_guess_clause_ind < 0 /*f->potential_units == NULL && f->potential_unit_count != 0*/)
	{
	  // Count unit clauses
	  for(i = 0; i < f->num_clauses; i++)	
	    if(!f->clauses[i].is_satisfied && is_unit_clause(f->clauses[i]))	
	      cur_unit_count++;
	  
	  f->potential_unit_count = cur_unit_count;
	}
      else
	{
	  cur_unit_count = f->potential_unit_count;
	}
  
      // If unit clauses were found, unit propogate them
      if(cur_unit_count)
	{
	  // Malloc space for the current unit clauses
	  cur_unit_clauses = malloc(sizeof(clause_index) * cur_unit_count);
	  cur_unit_lits = malloc(sizeof(int) * cur_unit_count);

	  // Determine the clause_index for each unit clause
	  int clause_index_count = 0;
	  if(last_guess_clause_ind < 0 /*f->potential_units == NULL && f->potential_unit_count != 0*/)
	    {
	      for(i = 0; i < f->num_clauses; i++)
		if(!f->clauses[i].is_satisfied && is_unit_clause(f->clauses[i]))
		  {
		    clause_index ci;
		    ci.clause = i;
		    ci.index = find_unit_lit(f->clauses[i]);
		    cur_unit_clauses[clause_index_count] = ci;
		    clause_index_count++;
		  }	   	
	    }
	  else
	    {
	      for(i = 0; i < f->potential_unit_count; i++)
		{
		  clause_index ci;
		  ci.clause = f->potential_units[i];
		  //printf("%d: clause #%d of %d\n", i, f->potential_units[i], f->num_clauses);
		  //print_clause(f->clauses[f->potential_units[i]]);
		  ci.index = find_unit_lit(f->clauses[f->potential_units[i]]);
		  cur_unit_clauses[clause_index_count] = ci;
		  clause_index_count++;
		} 
	    }
	  
	  free(f->potential_units);
	  f->potential_unit_count = 0;
	  f->potential_units = NULL;
	  
	  // Assign the associated literal
	  int l_index = 0;
	  for(; l_index < cur_unit_count; l_index++)
	    {
	      clause_index cur_cl = cur_unit_clauses[l_index];
	      literal cur_lit = f->clauses[cur_cl.clause].lits[cur_cl.index];
	      cur_unit_lits[l_index] = cur_lit.index;
	      guess(f, cur_lit.index, cur_lit.is_pos);	  	  	   
	      if(has_empty_clause(f))
		{
		  cur_unit_count = l_index + 1;
		  break;
		}
	    }	  
	  
	  // Free this struct array, it's no longer needed
	  if(cur_unit_clauses != NULL)
	    free(cur_unit_clauses);

	  // If no unit clauses have been found before this, use this array
	  if(unit_lits == NULL) 	    
	      unit_lits = cur_unit_lits;  
	  else // Otherwise, concatenate the existing and new unit clause arrays
	    unit_lits = concatenate_arrs(cur_unit_lits,cur_unit_count, unit_lits,unit_count);
	  unit_count += cur_unit_count;    	 
	}
      
      /** Count and assign pure literals **/

      // Count pure literals
      int cur_pure_count = 0;
      if(!has_empty_clause(f))
	{
	  if(last_guess_clause_ind < 0 /*f->potential_pures == NULL && f->potential_pure_count != 0*/)
	    {
	      for(i = 0; i < f->num_lits; i++)	
		if(!f->all_lits[i].lit.is_assigned &&
		   is_pure_literal(f->all_lits[i]))
		  cur_pure_count++;

	      f->potential_pure_count = cur_pure_count;
	    }
	  else
	    {
	      cur_pure_count = f->potential_pure_count;
	    }

	  // If any pure literals were found
	  int* cur_pure_lits = NULL;
	  if(cur_pure_count)
	    {
	      //printf("We've got %d pures\n", cur_pure_count);
	      int pure_ind = 0;
	      cur_pure_lits = malloc(sizeof(int)*cur_pure_count);
	  
	      // Fill cur_pure_lits with pure literals
	      if(last_guess_clause_ind < 0 /*f->potential_pures == NULL && f->potential_pure_count != 0*/)
		{
		  for(i = 0; i < f->num_lits; i++)	   
		    if(!f->all_lits[i].lit.is_assigned && is_pure_literal(f->all_lits[i]))
		      {
			cur_pure_lits[pure_ind] = i;
			pure_ind++;
		      }
		}
	      else
		{
		  for(i = 0; i < f->potential_pure_count; i++)	   
		    {
		      //printf("filling: %d (id: %d)\n", f->potential_pures[i], f->all_lits[f->potential_pures[i]].lit.id);
		      //print_lit_watch(*f, f->potential_pures[i]);
		      //if(!f->all_lits[f->potential_pures[i]].lit.is_assigned && is_pure_literal(f->all_lits[f->potential_pures[i]]))
			{
			  //printf("is it actually pure, or is it some hoe\n");
			  cur_pure_lits[pure_ind] = f->potential_pures[i];
			  pure_ind++;
			}
		    }
		}
	  
	      free(f->potential_pures);
	      f->potential_pures = NULL;
	      f->potential_pure_count = 0;

	      // Propogate the pure literals
	      for(i = 0; i < cur_pure_count; i++)
		{
		  // printf("%d of %d\n", i, cur_pure_count);
		  //printf("cur_pure_lits[%d] = %d and pure val: %d\n", i, cur_pure_lits[i], is_pure_literal(f->all_lits[cur_pure_lits[i]]));
		  int pure_val = is_pure_literal(f->all_lits[cur_pure_lits[i]]);
	      
		  if(pure_val > 0) // pure_val > 0 means set literal to 1
		    guess(f, cur_pure_lits[i], 1);
		  else if (pure_val < 0) // pure_val < 0 means set literal to 0
		    guess(f, cur_pure_lits[i], 0);
		  if(has_empty_clause(f))
		    {
		      cur_pure_count = i + 1;
		      break;
		    }
		}
	  
	      // Use this current array as the base if no pure literals existed
	      if(pure_lits == NULL)
		pure_lits = cur_pure_lits;
	      else // Otherwise, concatenate the existing and the current pures
		pure_lits = concatenate_arrs(cur_pure_lits,cur_pure_count, pure_lits,pure_count);	    
	      pure_count += cur_pure_count;    
	    }
	}
      
      // Determine if at leas one clause/literal was eliminated
      at_least_one_reduced = cur_unit_count | cur_pure_count;
      //printf("got %d units and %d pures\n", cur_unit_count, cur_pure_count);

    }
  //printf("FINAL: got %d units and %d pures\n", unit_count, pure_count);

  free(f->potential_pures);
  f->potential_pures = NULL;
  f->potential_pure_count = 0;
  free(f->potential_units);
  f->potential_units = NULL;
  f->potential_unit_count = 0;
  
  // If the previous guesses brought us to a satisfied state, that's awesome!
  if(is_satisfied(f))
    return 1;

  // Otherwise, check if an empty clause exists (because then we can backtrack)
  if(!has_empty_clause(f))
    {
      int found = 0;
      // pick next literal to guess as i
      int i;
      for(i = 0/*last_guess_clause_ind*/; i < f->num_lits; i++)
	{
	  // First literal that appears in an unsatisfied clause is chosen
	  // VERY naive, but it works
	  /*if(!f->clauses[i].is_satisfied && f->clauses[i].num_unassigned)
	    {	      
	      found = 1;
	      i = f->clauses[i].lits[find_unit_lit(f->clauses[i])].index;
	      break;
	    }
	  */

	  if(!f->all_lits[i].lit.is_assigned && f->all_lits[i].num_unsatisfied)
	    {
	      found = 1;
	      break;
	    }
	}

      // In the case a literal was found (may be unnecessary check)
      if(found)
	{
	  // Guess true and check for satisfiability after the guess
	  guess(f, i, 1);
      
	  if(is_satisfiable(f, i)) 
	    {
	      if(pure_lits != NULL)
		free(pure_lits);
	      if(unit_lits != NULL)
		free(unit_lits);  
	      return 1;
	    }

	  // Undo guess, because it wasn't satisfiable
	  undo_guess(f, i);
  
	  free(f->potential_pures);
	  f->potential_pures = NULL;
	  f->potential_pure_count = 0;
	  free(f->potential_units);
	  f->potential_units = NULL;
	  f->potential_unit_count = 0;

	  // Guess false for the same lit, and check for satisfiability again
	  guess(f, i, 0);

	  if(is_satisfiable(f, i))
	    {
	      if(pure_lits != NULL)
		free(pure_lits);
	      if(unit_lits != NULL)
		free(unit_lits);  
	      return 1;
	    }
	  free(f->potential_pures);
	  f->potential_pures = NULL;
	  f->potential_pure_count = 0;
	  free(f->potential_units);
	  f->potential_units = NULL;
	  f->potential_unit_count = 0;

	  // Undo guess, because we were wrong again!
	  undo_guess(f, i);
	}
    }
  f->has_empty_clause = 0;
  // undo unit clauses and pure literals guesses
  int ind = 0;
  for(; ind < unit_count; ind++)
    {
      undo_guess(f, unit_lits[ind]);
    }
  for(ind = 0; ind < pure_count; ind++)
    {
      undo_guess(f, pure_lits[ind]);
    }

  // Free arrays
  if(pure_lits != NULL)
    free(pure_lits);
  if(unit_lits != NULL)
    free(unit_lits);  
  //printf("going up\n");
  return 0;
}

/**
 * Adds the appropriate/associated indexes to the clauses' literals
 * The literal.index value corresponds to where the literal exists in all_lits
 **/
void fill_formula(formula* f)
{
  int i = 0;
  for(; i < f->num_lits; i++)
    {
      int j = 0;
      f->all_lits[i].purity = 0;
      f->all_lits[i].num_unsatisfied = f->all_lits[i].num_clauses;
      for(; j < f->all_lits[i].num_clauses; j++)
	{
	  clause_index ci = f->all_lits[i].clauses[j];
	  literal* lit = &(f->clauses[ci.clause].lits[ci.index]);
	  lit->index = i;
	  f->all_lits[i].purity += lit->is_pos;
	}
    }
}

/**
 * Function that debugs the watch list, and loudly complains if there is a bug
 **/
void debug_watch_list(formula* f)
{
  // loop through each literal
  int i = 0;
  for(; i < f->num_lits; i++)
    {
      int j = 0;     
      int occ[f->num_clauses];

      for(; j < f->num_clauses; j++)
	{
	  occ[j] = 0;
	}
      for(j = 0; j < f->all_lits[i].num_clauses; j++)
	{
	  clause_index ci = f->all_lits[i].clauses[j];	  
	  occ[ci.clause]++;
	  if(occ[ci.clause] > 1)
	    {
	      printf("THERE'S A BUG IN THE WATCHLIST (it's at %d - clause: %d, lit: %d\n",
		     occ[ci.clause], ci.clause, ci.index);
	      int x;
	      for(x = 0; x < f->all_lits[i].num_clauses; x++)
		{
		  clause_index ci = f->all_lits[i].clauses[x];
		  printf("%d -> %d\n", ci.clause, ci.index);
		}
	    }
	}
    }
}

int main(int argc, char** argv)
{
  int err = 0;
  // Parse the formula and verify it is correct
  formula f = verify(argc, argv, &err);
  if(err)    
      printf("ERROR\n");    
  else
    {
      // Fill the formula with indexes
      fill_formula(&f);

      if(is_satisfiable(&f, -1))
	printf("SATISFIABLE\n");
      else
	printf("UNSATISFIABLE\n");
    }
  
  // Free the formula's memory
  annhialate_formula(f);
}
